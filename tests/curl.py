#!/usr/bin/env python3
"""
Curl functionality for test framework - handles all curl operations
"""

from io import TextIOWrapper
import json
import subprocess
import requests
import time
from datetime import datetime
from typing import Dict, List, Tuple, Optional, Any, cast
from pathlib import Path

import json5

# class CurlResponse:
#     """Mock response object that mimics requests.Response for curl results"""
#     def __init__(self, status_code: int, text: str, url: str, elapsed_time: float):
#         self.status_code = status_code
#         self.text = text
#         self.url = url
#         self.elapsed = elapsed_time
#         self._json_data = None
    
#     def json(self):
#         """Parse JSON response like requests.Response.json()"""
#         if self._json_data is None:
#             try:
#                 self._json_data = json.loads(self.text)
#             except json.JSONDecodeError:
#                 self._json_data = {}
#         return self._json_data

class CurlManager:
    """Manages all curl-related operations"""
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.curl_file: Optional[TextIOWrapper] = None
        self.results: Dict[str, Any] = {}  # Store responses by URL
    
    def create_curl_script(self) -> bool:
        """Create curl.sh with execute_url function"""
        try:
            self.curl_file = open('tests/curl.sh', 'w')
            self.curl_file.write('#!/bin/bash\n')
            self.curl_file.write('# Generated curl commands from comprehensive test execution\n') 
            self.curl_file.write('# Auto-generated by --curl mode\n\n')
            
            # Add execute_url function for consistent URL handling
            self.curl_file.write('''# Function to execute a URL and output structured JSON
execute_url() {
    local method="$1"
    local url="$2" 
    local description="$3"
    
    # Execute curl and capture full response with status
    local full_response=$(curl -s -w "\\nSTATUS:%{http_code}" -X "$method" "$url")
    local response_body=$(echo "$full_response" | sed '$d')  # Remove last line (status)
    local status=$(echo "$full_response" | tail -n 1 | sed 's/STATUS://')  # Extract status code
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
    
    # Output structured result with full response
    echo "{"
    echo "  \\"method\\": \\"$method\\","
    local url_path=$(echo "$url" | sed 's|^http[s]*://[^/]*||')
    echo "  \\"url\\": \\"$url_path\\","
    echo "  \\"description\\": \\"$description\\","
    echo "  \\"status\\": $status,"
    echo "  \\"timestamp\\": \\"$timestamp\\","
    echo "  \\"response\\": $response_body"
    echo "},"
}

''')
            if self.verbose:
                print("📁 Initialized tests/curl.sh - will generate curl commands only")
            return True
        except Exception as e:
            if self.verbose:
                print(f"⚠️ Warning: Could not initialize tests/curl.sh: {e}")
            return False
    
    def close_curl_file(self):
        """Close curl file if open"""
        if self.curl_file:
            try:
                self.curl_file.close()
            except:
                pass
        self.curl_file = None
    
    def get_curl_file_handle(self):
        """Get curl file handle for writing commands"""
        return self.curl_file
    
    def load_json_responses_file(self, filename: str) -> Optional[Dict[str, Any]]:
        """Load JSON responses from manual curl.sh execution (no config sections)"""
        try:
            with open(filename, 'r') as f:
                content = f.read()

            print("📁 Parsing json - this may take 30 sec...")
            parsed = cast(List[Dict[str, Any]], json5.loads('[' + content + ']'))  # Validate JSON5 format

            if parsed:
                self.results = {
                    item['url']: {
                    'status': item['status'],
                    'description': item['description'],
                    'response': item['response']
                }
                for item in parsed 
            }

            if self.verbose:
                print(f"✅ Loaded {len(self.results)} responses from {filename}")
            
            return self.results
            
        except Exception as e:
            if self.verbose:
                print(f"❌ Error loading JSON responses file: {e}.  Was the server running when the curl.sh was executed?")
            return None

    def _parse_result_line(self, line: str) -> Dict[str, Any]:
        """Parse CURL_RESULT line into components"""
        # Format: CURL_RESULT|STATUS:200|TIME:0.004|URL:http://...
        try:
            parts = line.split('|')[1:]  # Skip CURL_RESULT prefix
            result: Dict[str, Any] = {}
            
            for part in parts:
                if ':' in part:
                    key, value = part.split(':', 1)
                    if key == 'STATUS':
                        result['status'] = int(value)
                    elif key == 'TIME':
                        result['time'] = float(value)
                    elif key == 'URL':
                        result['url'] = value
            
            return result
        except Exception as e:
            if self.verbose:
                print(f"⚠️ Warning: Could not parse result line: {line} - {e}")
            return {}
    
    @staticmethod
    def make_api_request(method: str, url: str, expected_status: int = 200, data: Dict = {}) -> Tuple[int, Dict]:
        """Simple HTTP request - returns (status_code, response_dict)"""
        try:
            if method.upper() == "GET":
                response = requests.get(url, timeout=30)
            elif method.upper() == "POST":
                response = requests.post(url, json=data, timeout=30)
            elif method.upper() == "PUT":
                response = requests.put(url, json=data, timeout=30)
            elif method.upper() == "DELETE":
                response = requests.delete(url, timeout=30)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            try:
                return response.status_code, response.json()
            except:
                return response.status_code, {"raw_response": response.text}
                
        except Exception as e:
            return 500, {"error": str(e)}