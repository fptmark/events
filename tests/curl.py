#!/usr/bin/env python3
"""
Curl functionality for test framework - handles all curl operations
"""

from io import TextIOWrapper
import json
import subprocess
from typing import Dict, List, Tuple, Optional, Any, cast
from pathlib import Path

import json5

# class CurlResponse:
#     """Mock response object that mimics requests.Response for curl results"""
#     def __init__(self, status_code: int, text: str, url: str, elapsed_time: float):
#         self.status_code = status_code
#         self.text = text
#         self.url = url
#         self.elapsed = elapsed_time
#         self._json_data = None
    
#     def json(self):
#         """Parse JSON response like requests.Response.json()"""
#         if self._json_data is None:
#             try:
#                 self._json_data = json.loads(self.text)
#             except json.JSONDecodeError:
#                 self._json_data = {}
#         return self._json_data

class CurlManager:
    """Manages all curl-related operations"""
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.curl_file: Optional[TextIOWrapper] = None
        self.results: Dict[str, Any] = {}  # Store responses by URL
    
    def create_curl_script(self) -> bool:
        """Create curl.sh with execute_url function"""
        try:
            self.curl_file = open('tests/curl.sh', 'w')
            self.curl_file.write('#!/bin/bash\n')
            self.curl_file.write('# Generated curl commands from comprehensive test execution\n') 
            self.curl_file.write('# Auto-generated by --curl mode\n\n')
            
            # Add execute_url function for consistent URL handling
            self.curl_file.write('''# Function to execute a URL and output structured JSON
execute_url() {
    local method="$1"
    local url="$2" 
    local description="$3"
    
    # Execute curl and capture full response with status
    local full_response=$(curl -s -w "\\nSTATUS:%{http_code}" -X "$method" "$url")
    local response_body=$(echo "$full_response" | sed '$d')  # Remove last line (status)
    local status=$(echo "$full_response" | tail -n 1 | sed 's/STATUS://')  # Extract status code
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
    
    # Output structured result with full response
    echo "{"
    echo "  \\"method\\": \\"$method\\","
    local url_path=$(echo "$url" | sed 's|^http[s]*://[^/]*||')
    echo "  \\"url\\": \\"$url_path\\","
    echo "  \\"description\\": \\"$description\\","
    echo "  \\"status\\": $status,"
    echo "  \\"timestamp\\": \\"$timestamp\\","
    echo "  \\"response\\": $response_body"
    echo "},"
}

''')
            if self.verbose:
                print("üìÅ Initialized tests/curl.sh - will generate curl commands only")
            return True
        except Exception as e:
            if self.verbose:
                print(f"‚ö†Ô∏è Warning: Could not initialize tests/curl.sh: {e}")
            return False
    
    def close_curl_file(self):
        """Close curl file if open"""
        if self.curl_file:
            try:
                self.curl_file.close()
            except:
                pass
        self.curl_file = None
    
    def get_curl_file_handle(self):
        """Get curl file handle for writing commands"""
        return self.curl_file
    
    def load_json_responses_file(self, filename: str) -> Optional[Dict[str, Any]]:
        """Load JSON responses from manual curl.sh execution (no config sections)"""
        try:
            with open(filename, 'r') as f:
                content = f.read()

            print("üìÅ Parsing json - this may be slow...")
            parsed = cast(List[Dict[str, Any]], json5.loads('[' + content + ']'))  # Validate JSON5 format

            if parsed:
                self.results = {
                    item['url']: {
                    'status': item['status'],
                    'description': item['description'],
                    'response': item['response']
                }
                for item in parsed 
            }

            if self.verbose:
                print(f"‚úÖ Loaded {len(self.results)} responses from {filename}")
            
            return self.results
            
        except Exception as e:
            if self.verbose:
                print(f"‚ùå Error loading JSON responses file: {e}.  Was the server running when the curl.sh was executed?")
            return None

    def _parse_result_line(self, line: str) -> Dict[str, Any]:
        """Parse CURL_RESULT line into components"""
        # Format: CURL_RESULT|STATUS:200|TIME:0.004|URL:http://...
        try:
            parts = line.split('|')[1:]  # Skip CURL_RESULT prefix
            result = {}
            
            for part in parts:
                if ':' in part:
                    key, value = part.split(':', 1)
                    if key == 'STATUS':
                        result['status'] = int(value)
                    elif key == 'TIME':
                        result['time'] = float(value)
                    elif key == 'URL':
                        result['url'] = value
            
            return result
        except Exception as e:
            if self.verbose:
                print(f"‚ö†Ô∏è Warning: Could not parse result line: {line} - {e}")
            return {}